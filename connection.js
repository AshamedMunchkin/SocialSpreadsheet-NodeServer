// Generated by CoffeeScript 1.6.2
var Connection, DEBUG, async, events,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

events = require('events');

async = require('async');

DEBUG = true;

Connection = (function(_super) {
  __extends(Connection, _super);

  function Connection(socket, server) {
    var _this = this;

    this.socket = socket;
    this.server = server;
    this.buffer = '';
    this.socket.setEncoding('utf8');
    this.socket.on('data', function(data) {
      _this.buffer += String(data);
      return _this.emit('data');
    });
    console.log('Connection created');
  }

  Connection.prototype.start = function() {
    var _this = this;

    return this.readUntil('\n', function(command) {
      return _this.primaryHandler(command);
    });
  };

  Connection.prototype.primaryHandler = function(command) {
    var _this = this;

    switch (command) {
      case 'CREATE':
      case 'JOIN':
        return async.series({
          name: function(callback) {
            return _this.readUntil('\n', function(response) {
              var name;

              name = response.substring(5);
              return callback(null, name);
            });
          },
          password: function(callback) {
            return _this.readUntil('\n', function(response) {
              var password;

              password = response.substring(9);
              return callback(null, password);
            });
          }
        }, function(error, results) {
          switch (command) {
            case 'CREATE':
              _this.server.create(_this, results.name, results.password);
              break;
            default:
              _this.server.join(_this, results.name, results.password);
          }
          return _this.start();
        });
      case 'CHANGE':
        return async.series({
          name: function(callback) {
            return _this.readUntil('\n', function(response) {
              var name;

              name = response.substring(5);
              return callback(null, name);
            });
          },
          version: function(callback) {
            return _this.readUntil('\n', function(response) {
              var version;

              version = response.substring(8);
              return callback(null, version);
            });
          },
          cell: function(callback) {
            return _this.readUntil('\n', function(response) {
              var cell;

              cell = response.substring(5);
              return callback(null, cell);
            });
          },
          length: function(callback) {
            return _this.readUntil('\n', function(response) {
              var length;

              length = response.substring(7);
              return callback(null, length);
            });
          },
          content: function(callback) {
            return _this.readUntil('\n', function(content) {
              return callback(null, content);
            });
          }
        }, function(error, results) {
          _this.server.change(_this, results.name, results.version, results.cell, results.content);
          return _this.start();
        });
      case 'UNDO':
        return async.series({
          name: function(callback) {
            return _this.readUntil('\n', function(response) {
              var name;

              name = response.substring(5);
              return callback(null, name);
            });
          },
          version: function(callback) {
            return _this.readUntil('\n', function(response) {
              var version;

              version = response.substring(8);
              return callback(null, version);
            });
          }
        }, function(error, results) {
          _this.server.undo(_this, results.name, results.version);
          return _this.start();
        });
      case 'SAVE':
      case 'LEAVE':
        return async.series({
          name: function(callback) {
            return _this.readUntil('\n', function(response) {
              var name;

              name = response.substring(5);
              return callback(null, name);
            });
          }
        }, function(error, results) {
          switch (command) {
            case 'SAVE':
              _this.server.save(_this, results.name);
              break;
            default:
              _this.server.leave(_this, results.name);
          }
          return _this.start();
        });
      default:
        this.sendMessage("ERROR\n");
        return this.start();
    }
  };

  Connection.prototype.readUntil = function(delimiter, callback) {
    var index, result;

    index = this.buffer.indexOf(delimiter);
    if (index !== -1) {
      result = this.buffer.substring(0, index);
      this.buffer = this.buffer.substring(index + delimiter.length);
      if (DEBUG) {
        console.log("\n" + result);
      }
      callback(result);
      return;
    }
    return this.once('data', function() {
      return this.readUntil(delimiter, callback);
    });
  };

  Connection.prototype.sendMessage = function(message) {
    if (DEBUG) {
      console.log("\n" + message);
    }
    return this.socket.write(message);
  };

  return Connection;

})(events.EventEmitter);

module.exports = Connection;
